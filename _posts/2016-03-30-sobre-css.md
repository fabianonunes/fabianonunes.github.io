---
published: true
title: Sobre CSS
layout: post
---

No ano passado, comecei a reescrever algumas folhas de estilos. N√£o por que estavam mal elaboradas, mas porque n√£o eram reutiliz√°veis.

Meu objetivo era adotar na √°rea de design os mesmos **princ√≠pios** que os programadores estudam desde o primeiro _hello world!_.

Como ponto de partida, vou utilizar um trecho css sugerido por um colega:

```css
[href$=".zip"]:before, [href$=".gz"]:before {
   content: '\E004'; /* unicode for the zip folder icon */
}
```

Embora seja um m√©todo muito inteligente e bem elaborado, √© uma das t√©cnicas que tento combater. √Ä primeira vista, s√£o uma m√£o na roda. Por√©m, al√©m de quebrarem alguns princ√≠pios, podem causar problemas que s√≥ ser√£o contornados com a quebra de outros princ√≠pios.

Seguem alguns exemplos.


### Single Source of Truth

Ao configurar como se comportam **todos** os elementos que combinem com `[href$='zip']`, interferimos na autonomia de outros componentes, j√° que, implicitamente, duplicamos as regras que os definem.

Um determinado componente afetado por esse seletor, a partir de agora, possui dois comportamentos: um global e um espec√≠fico, ambos localizados em pontos distintos da base de c√≥digo.

```css
/* callout.css */
.Callout--special:before {
  content: 'ol√°!';
  border: 1px solid red;
}
```

```html
<a class="Callout Callout--special" href="teste.zip">Download aqui</a>
```

Uma vez que n√£o √© poss√≠vel acumular dois pseudos-elementos, um dos `:before` vai perder. A depender da especificidade de cada um, podemos ter um cen√°rio n√£o desejado por nenhuma das regras: um `\E004` com borda vermelha.

A apropria√ß√£o impl√≠cita de um `:before` condicionou inesperadamente um estilo a um elemento.


### Explicit is better than implicit

> Um comportamento impl√≠cito reduz invariavelmente sua previsibilidade.

```html
<a href="http://um_encurtador_de_url_qualquer/Jh6&kJzip">Arquivo PDF</a>
<a href="http://meu_servidor/stream">Arquivo ZIP</a>
```

No primeiro caso, temos um falso positivo; no segundo, um falso negativo.


### Immutability

> Imut√°veis s√£o aqueles objetos que, depois de criados, n√£o podem ter seus estados alterados.

N√£o vejo princ√≠pio mais √∫til que este para um CSS de larga escala.

Componentes imut√°veis s√£o confi√°veis, s√£o agn√≥sticos √† sua localiza√ß√£o no DOM, s√£o previs√≠veis e simplificam o seu entendimento. Quando uma classe √© global mas n√£o tem o intuito de ser global (que √© o caso em quest√£o), ela pode desfazer essa  imutabilidade.

Aqui, o componente `.Callout--special` foi alterado por um agente externo, fora de seu escopo e de seu alcance.


### Open/Closed (adaptado √† realidade CSS)

> As defini√ß√µes devem ser permitir extens√µes (open), mas coibir modifica√ß√µes (closed).

Imagine que voc√™ seja um _consumer_ de duas bibliotecas css.

* `superultra-2.2.2.css`, que comporta o trecho sugerido; e
* `framework_embutido_no_CMS-9.9.9.css`, que comporta o `.Callout`.

Das duas uma: (i) ou voc√™ modifica um desses arquivos (que n√£o s√£o seus) e mant√©m um fork, ou (ii) cria um arquivo `.css` e adiciona a seguinte linha:

```css
/* o odiado !important reativo */
.Callout--special:before {
  content: 'ol√°!'!important;
}
```

Acabamos de modificar dois comportamentos: aquele que *deveria* ser global (pois deixar√° de ser `\E004`) e o espec√≠fico (que n√£o deveria ser `!important`).


## Alternativas

Seguem algumas alternativas. Elas podem parecer pouco pr√°ticas, mas, na minha opini√£o, s√£o flex√≠veis, reutiliz√°veis e de f√°cil entendimento.

```html
<a href="/meu-arquivo.zip">
  <span class="glyphicon glyphicon-package"></span>
  Arquivo
</a>
```

```html
<a class="Callout Callout--pdf" href="/meu-relatorio.pdf">
  Relat√≥rio
</a>
```

```html
<a class="callout callout-pdf" href="/meu-relatorio.pdf">
  Relat√≥rio
</a>
```

## Desafios

### Sintaxe

√â o principal desafio. Eu nunca imaginaria que uma letra mai√∫scula causaria tanta controv√©rsia.

üòÄ `p ~ li > ul + p > div > a ~ b:first-child(:not(div + p)) { ... }`

üòÄ `#id { ... }`

üò± `.Callout { ... }`

### Confus√£o de conceitos

Dizem que _'essa classe n√£o √© sem√¢ntica!!!'_, mas veneram o Bootstrap.

* `.row` √© sem√¢ntica?
* `.col-offset-xs-12 .col-pull-sm-5` √© sem√¢ntica?
* `.pull-right .hidden-xs` √© sem√¢ntica?
* `.clearfix` √© sem√¢ntica?
* `<nav class="nav navbar navbar-nav navbar-default collapse navbar-collapse"/>` √© sem√¢ntica?

Quer saber o que eu acho? Sigo o relator:

> ‚Äú(...) Not all semantics need to be content-derived. Class names cannot be ‚Äòunsemantic‚Äô. Whatever names are being used: they have meaning, they have purpose‚Äù -- [Nicolas Gallagher](http://nicolasgallagher.com/about-html-semantics-front-end-architecture/)

Estamos em 2016. Aquela √©poca de CSS Zen Garden j√° passou. **H√° 13 anos!!!**

### √â isso

Escrevi demais. E nem abordei todos os princ√≠pios aplic√°veis, tais como:

- Don't repeat yourself
- Single Responsability Principle
- KISS

Temos uma variedade de portais, cada qual com seu framework, cada qual com seu grupo de desenvolvedores. √â dif√≠cil implementar uma regra geral que se encaixe em todos os _workflows_. N√£o acredito que essa abordagem apresentada seja definitiva, mas √© um come√ßo.

## Refer√™ncias

* Nicole Sullivan [OOCSS] @stubbornella
* Lea Verou [Secrets of CSS ] @leaverou
* Jonathan Snook [SMACSS] @snookca
* Harry Roberts [inuitcss] @csswizardry
* Nicolas Gallagher [suitcss] @necolas
* Yandex [BEM] @bem_en
